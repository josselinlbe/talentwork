import { Entity, EntityProperty, EntityPropertyOption } from "@prisma/client";
import { EntityLimitType } from "~/application/enums/entities/EntityLimitType";
import { db } from "../db.server";
import { defaultEntityProperties } from "../helpers/EntityPropertyHelper";

export type EntityRowsUsage = { entityId: string; _count: number };
export type EntityWithDetails = Entity & { properties: EntityPropertyWithDetails[] };
export type EntityWithCount = EntityWithDetails & { _count: { rows: number } };

export type EntityPropertyWithDetails = EntityProperty & {
  // entity: EntityWithDetails;
  options: EntityPropertyOption[];
  parent?: EntityPropertyWithDetails;
};

const includePropertiesWithDetails = {
  properties: {
    include: {
      options: true,
    },
  },
};

export async function getAllEntities(active?: boolean): Promise<Entity[]> {
  let where = {};
  if (active) {
    where = {
      active,
    };
  }
  return await db.entity.findMany({
    where,
    orderBy: [
      {
        order: "asc",
      },
    ],
  });
}

export async function getAllEntitiesWithRowCount(): Promise<EntityWithCount[]> {
  return await db.entity.findMany({
    include: {
      _count: {
        select: {
          rows: true,
        },
      },
      properties: {
        orderBy: { order: "asc" },
        include: {
          // entity: {
          //   include: {
          //     ...includePropertiesWithDetails,
          //   },
          // },
          options: true,
        },
      },
    },
  });
}

export async function getAllEntityRowsUsage(tenantId: string): Promise<EntityRowsUsage[]> {
  const countEntities = await db.entityRow.groupBy({
    by: ["entityId"],
    _count: true,
    where: {
      OR: [
        {
          tenantId,
        },
        {
          linkedAccount: {
            OR: [
              {
                providerTenantId: tenantId,
              },
              {
                clientTenantId: tenantId,
              },
            ],
          },
        },
      ],
    },
  });
  return countEntities;
}

export async function getEntityRowsCount(tenantId: string, entityId: string): Promise<number> {
  const whereTenant = {
    OR: [
      {
        tenantId,
      },
      {
        linkedAccount: {
          OR: [
            {
              providerTenantId: tenantId,
            },
            {
              clientTenantId: tenantId,
            },
          ],
        },
      },
    ],
  };
  if (!entityLimit || entityLimit.type === EntityLimitType.MAX) {
    return await db.entityRow.count({
      where: {
        entityId,
        ...whereTenant,
      },
    });
  } else {
    return await db.entityRow.count({
      where: {
        entityId: entityLimit.entityId,
        ...whereTenant,
        // TODO: CURRENT MONTH
      },
    });
  }
}

export async function getEntityById(id: string): Promise<EntityWithDetails | null> {
  return await db.entity.findUnique({
    where: {
      id,
    },
    include: {
      properties: {
        orderBy: { order: "asc" },
        include: {
          // entity: {
          //   include: {
          //     ...includePropertiesWithDetails,
          //   },
          // },
          options: true,
        },
      },
    },
  });
}

export async function getEntityBySlug(slug: string): Promise<EntityWithDetails | null> {
  return await db.entity.findFirst({
    where: {
      slug,
    },
    include: {
      properties: {
        orderBy: { order: "asc" },
        include: {
          // entity: {
          //   include: {
          //     ...includePropertiesWithDetails,
          //   },
          // },
          options: true,
        },
      },
    },
  });
}

export async function getEntityByOrder(order: number): Promise<Entity | null> {
  return await db.entity.findFirst({
    where: {
      order,
    },
  });
}

export async function getEntityByPrefix(prefix: string): Promise<Entity | null> {
  return await db.entity.findFirst({
    where: {
      prefix,
    },
  });
}

export async function createEntity(data: {
  name: string;
  slug: string;
  order: number;
  prefix: string;
  title: string;
  titlePlural: string;
  isFeature: boolean;
  isAutogenerated: boolean;
  hasApi: boolean;
  requiresLinkedAccounts: boolean;
  icon: string;
  active: boolean;
}) {
  const entity = await db.entity.create({
    data,
  });

  const webhooks = [
    {
      action: "Created",
      method: "POST",
      endpoint: "",
    },
    {
      action: "Updated",
      method: "POST",
      endpoint: "",
    },
    {
      action: "Deleted",
      method: "POST",
      endpoint: "",
    },
  ];

  await Promise.all(
    webhooks.map(async (webhook) => {
      return await db.entityWebhook.create({
        data: {
          entityId: entity.id,
          action: webhook.action,
          method: webhook.method,
          endpoint: webhook.endpoint,
        },
      });
    })
  );

  await Promise.all(
    defaultEntityProperties.map(async (property) => {
      return await db.entityProperty.create({
        data: {
          entityId: entity.id,
          ...property,
        },
      });
    })
  );

  return entity;
}

export async function updateEntity(
  id: string,
  data: {
    name: string;
    slug: string;
    order: number;
    prefix: string;
    title: string;
    titlePlural: string;
    isFeature: boolean;
    isAutogenerated: boolean;
    hasApi: boolean;
    requiresLinkedAccounts: boolean;
    icon: string;
    active: boolean;
  }
) {
  console.log({ data });
  return await db.entity.update({
    where: {
      id,
    },
    data,
  });
}

export async function deleteEntity(id: string) {
  return await db.entity.delete({
    where: {
      id,
    },
  });
}
